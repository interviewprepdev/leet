1. Don't do a hashmap.get(value)++ won't work. What would work is hashmap.get(value) + 1. Yet to figure out why maby just bracketing might fix not sure
2. (char)('A' + n % 26) -- if n was 1 this will be character B and so on. ASCII addition
3. sb.charAt(i), sb.deleteCharAt(i) -- stringbuilder methods
4. extends LinkedHashMapp<Integer, Integer> and constructor LRUCache(capacity, 0.75F, accessOrder:true); to main the order in which the elements where accessed
5. both string and stringbuilder accessing element is O(1) using s.charAt(i)
6. Queue<int[]> pq = new PriorityQueue<>((b-a)-> grid[b[0]][b[1]]) - grid[a[0]][a[1]]); // this is desending order as b comes first
7. Map.Entry<Character, Integer> e = hm.entrySet().iterator().next();
8. cannot do string + char will not work, either use stringbuilder.append(char) or new string(new char[] {'a', 'b', 'c'});
9. whatever size we specify during initializaiton of PQ is just the init size, it has the capacity to grow on its own
10. Collections.sort() Operates on List Whereas Arrays.sort() Operates on an Array.
Arrays.sort() uses Dual-Pivot Quicksort for Primitive Arrays and MergeSort for sorting array of Objects.
Example of Collections.sort() :
 ArrayList<Integer> arr = new ArrayList<Integer>();
 arr.add(15);
 arr.add(10);
 arr.add(5); 
 arr.add(2); 

 Collections.sort(arr);
Example of Arrays.sort() :

int[] arr = new int[4]
 arr[0]=15;
 arr[1]=10;
 arr[2]=5; 
 arr[3]=2; 

 Arrays.sort(arr);
 
 Even 2-D arrays can be sorted using Arrays.sort(intervals, (b, a)-> a[0]-b[0]);
11. ArrayList<int[]> res = new ArrayList<>();
12. To convert arraylist to int[]: arrayList.toArray(new int[arrayList.size()]);





Good article on object level vs class level locks in java:
https://howtodoinjava.com/java/multi-threading/object-vs-class-level-locking/


java cheatsheet to refer:
https://github-com.translate.goog/jsjtzyy/LeetCode/blob/master/Java%20cheat%20sheet%20for%20interview?_x_tr_sl=zh-CN&_x_tr_tl=en&_x_tr_hl=en&_x_tr_pto=sc
